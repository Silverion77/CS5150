// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Initialization for the EE library.
 */

goog.provide('ee');

/**
 * Initialize the library.  If this hasn't been called by the time any
 * object constructor is used, it will be called then.  If this is called
 * a second time with a different baseurl or tileurl, this doesn't do an
 * un-initialization of e.g.: the previously loaded Algorithms, but will
 * overwrite them and let point at alternate servers.
 *
 * @param {string?=} opt_baseurl The (proxied) EarthEngine REST API endpoint.
 * @param {string?=} opt_tileurl The (unproxied) EarthEngine REST tile endpoint.
 * @param {function()=} opt_callback An optional callback to be invoked when
 *     the initialization is done.  If not provided the initialization is
 *     done synchronously.
 */
ee.initialize = function(opt_baseurl, opt_tileurl, opt_callback) {
  // If we're already initialized and not getting new parameters, just return.
  if (ee.ready_ == ee.InitState.READY && !opt_baseurl && !opt_tileurl) {
    return;
  } else if (ee.ready() == ee.InitState.LOADING) {
    throw new Error('Already loading.');
  }

  ee.ready_ = ee.InitState.LOADING;
  ee.url_base_ = opt_baseurl || '/api';
  ee.tile_base_ = opt_tileurl || 'https://earthengine.googleapis.com';

  // Initialize the dynamically loaded functions on the objects that want them.
  var finish = function() {
    ee.Algorithms.addFunctions(ee.Image, 'Image');
    ee.Algorithms.addFunctions(ee.Feature, 'Feature');
    ee.Algorithms.addFunctions(ee.FeatureCollection, 'FeatureCollection');
    ee.Algorithms.addFunctions(ee.Image, 'Window', 'focal_');
    ee.Algorithms.addFunctions(ee.ImageCollection, 'ImageCollection');
    ee.Algorithms.addFunctions(ee.ImageCollection, 'reduce');
    ee.Algorithms.addFunctions(ee.Collection, 'Collection');
    ee.Algorithms.addFunctions(ee.Collection,
                               'AggregateFeatureCollection',
                               'aggregate_',
                               ee.Algorithms.makeAggregateFunction);
    ee.Algorithms.addFunctions(ee.ImageCollection,
                               'Image',
                               'map_',
                               ee.Algorithms.makeMapFunction);
    ee.Algorithms.addFunctions(ee.FeatureCollection,
                               'Feature',
                               'map_',
                               ee.Algorithms.makeMapFunction);
    ee.ready_ = ee.InitState.READY;
    if (opt_callback) {
      opt_callback();
    }
  };

  if (opt_callback) {
    ee.Algorithms.init(finish);
  } else {
    try {
      ee.Algorithms.init();
      finish();
    } catch (e) {
      alert('Could not read algorithm list.');
    }
  }
};

/**
 * The possible states for the library initialization function.  We want
 * to prohibit multiple overlapping calls, and allow the user a way to poll
 * to see what the state is.
 *
 * @enum {string}
 */
ee.InitState = {
  NOT_READY: 'not_ready',
  LOADING: 'loading',
  READY: 'ready'
};

/**
 * A flag to indicate the initialization state.
 * @private
 */
ee.ready_ = ee.InitState.NOT_READY;

/**
 * @type {string?} The base URL for all data calls.
 * @private
 */
ee.url_base_ = null;

/**
 * @type {string?} The base URL for map tiles.
 * @private
 */
ee.tile_base_ = null;

/**
 * @type {number} The size of a tile generated by the /map servlet.
 */
ee.TILE_SIZE = 256;

/**
 * @return {ee.InitState} The initialization status.
 */
ee.ready = function() {
  return ee.ready_;
};

/**
 * Call the specified algorithm with the given positional arguments.
 *
 * @param {string|Object} name The name of the algorithm or a lambda.
 * @param {...*} var_args Positional arguments to pass to the algorithm.
 *
 * @return {*} An object representing the called algorithm.  If the signature
 *     specifies a recognized return type, the returned value will be wrapped
 *     in that type.  Otherwise, the return is just the JSON description of the
 *     algorithm invocation.
 */
ee.call = function(name, var_args) {
  if (goog.isString(name)) {
    var algorithm = ee.Algorithms.get(name);
    var argsIn = Array.prototype.slice.call(arguments, 1);
    return ee.Algorithms.applySignature_(algorithm, argsIn, {});
  } else {
    var argNames = name['args'];
    if (!argNames || argNames.length > arguments.length - 1) {
      throw Error('Missing lambda arguments: ' +
                  argNames.slice(arguments.length - 1));
    }
    var applied = {'algorithm': name};
    for (var i = 1; i < arguments.length; i++) {
      applied[argNames[i - 1]] = arguments[i];
    }
    return applied;
  }
};

/**
 * Call the specified algorithm with a dictionary of named arguments.
 *
 * @param {string|Object} name The name of the algorithm or a lambda.
 * @param {Object} namedArgs A dictionary of arguments to the algorithm.
 *
 * @return {*} An object representing the called algorithm.  If the signature
 *     specifies a recognized return type, the returned value will be wrapped
 *     in that type.  Otherwise, the return is just the JSON description of the
 *     algorithm invocation.
 */
ee.apply = function(name, namedArgs) {
  if (goog.isString(name)) {
    var algorithm = ee.Algorithms.get(/** @type {string} */ (name));
    return ee.Algorithms.applySignature_(algorithm, [], namedArgs);
  } else {
    var applied = goog.object.clone(namedArgs);
    applied['algorithm'] = name;
    return applied;
  }
};

/**
 * Returns a placeholder variable with a given name that implements a given
 * EE type.
 *
 * @param {function(this:Object, ?): Object} type A type to mimic.
 * @param {string} name The name of the variable as it will appear in the
 *     arguments of the lambdas that use this variable.
 *
 * @return {*} A placeholder with the specified name implementing the specified
 *     type.
 */
ee.variable = function(type, name) {
  var placeholder = {
    description_: {
      'type': 'Variable',
      'name': name
    }
  };
  placeholder.__proto__ = type.prototype;
  return placeholder;
};

/**
 * Returns an EE lambda object that can be used in place of algorithms with a
 * given set of arguments and an expression to evaluate.
 *
 * @param {Array.<string>} args The names of the arguments to the lambda.
 * @param {Object} body The expression to evaluate.
 *
 * @return {Object} An EE lambda object that can be used in place of algorithms.
 */
ee.lambda = function(args, body) {
  return {
    'type': 'Algorithm',
    'args': args,
    'body': body
  };
};

goog.exportSymbol('ee.initialize', ee.initialize);
goog.exportSymbol('ee.InitState', ee.InitState);
goog.exportSymbol('ee.InitState.NOT_READY', ee.InitState.NOT_READY);
goog.exportSymbol('ee.InitState.LOADING', ee.InitState.LOADING);
goog.exportSymbol('ee.InitState.READY', ee.InitState.READY);
goog.exportSymbol('ee.ready', ee.ready);
goog.exportSymbol('ee.call', ee.call);
goog.exportSymbol('ee.apply', ee.apply);
goog.exportSymbol('ee.variable', ee.variable);
goog.exportSymbol('ee.lambda', ee.lambda);
goog.exportSymbol('ee.TILE_SIZE', ee.TILE_SIZE);
